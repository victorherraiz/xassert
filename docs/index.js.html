<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-xassert.Assertion.html">Assertion</a><ul class='methods'><li data-type='method'><a href="module-xassert.Assertion.html#doesNotHaveOwnProperty">doesNotHaveOwnProperty</a></li><li data-type='method'><a href="module-xassert.Assertion.html#doesNotHaveProperty">doesNotHaveProperty</a></li><li data-type='method'><a href="module-xassert.Assertion.html#every">every</a></li><li data-type='method'><a href="module-xassert.Assertion.html#getFullName">getFullName</a></li><li data-type='method'><a href="module-xassert.Assertion.html#getName">getName</a></li><li data-type='method'><a href="module-xassert.Assertion.html#getRef">getRef</a></li><li data-type='method'><a href="module-xassert.Assertion.html#hasLength">hasLength</a></li><li data-type='method'><a href="module-xassert.Assertion.html#hasLengthOf">hasLengthOf</a></li><li data-type='method'><a href="module-xassert.Assertion.html#hasOwnProperty">hasOwnProperty</a></li><li data-type='method'><a href="module-xassert.Assertion.html#hasProperty">hasProperty</a></li><li data-type='method'><a href="module-xassert.Assertion.html#is">is</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isAnArray">isAnArray</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isANumber">isANumber</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isAPromise">isAPromise</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isAString">isAString</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isDeeplyEqualTo">isDeeplyEqualTo</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isDeeplyEqualToAnyOf">isDeeplyEqualToAnyOf</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isEqualTo">isEqualTo</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isEqualToAnyOf">isEqualToAnyOf</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNaN">isNaN</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotAnArray">isNotAnArray</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotANumber">isNotANumber</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotAPromise">isNotAPromise</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotAString">isNotAString</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotDeeplyEqualTo">isNotDeeplyEqualTo</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotDeeplyEqualToAnyOf">isNotDeeplyEqualToAnyOf</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotEqualTo">isNotEqualTo</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotEqualToAnyOf">isNotEqualToAnyOf</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotNaN">isNotNaN</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotNull">isNotNull</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNotUndefined">isNotUndefined</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isNull">isNull</a></li><li data-type='method'><a href="module-xassert.Assertion.html#isUndefined">isUndefined</a></li><li data-type='method'><a href="module-xassert.Assertion.html#named">named</a></li><li data-type='method'><a href="module-xassert.Assertion.html#some">some</a></li></ul></li><li><a href="module-xassert.AssertionError.html">AssertionError</a></li></ul><h3>Modules</h3><ul><li><a href="module-xassert.html">xassert</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint valid-jsdoc: 2 */
'use strict'

/**
 * Extensible assertions
 * @module xassert
 */

function isAPromise (promise) {
  return promise !== null &amp;&amp;
    (typeof promise === 'object' || typeof promise === 'function') &amp;&amp;
    typeof promise.then === 'function'
}

function deepEquals (a, b) {
  if (a === b) return true
  if (a === null || b === null) return false

  const type = typeof a
  const otherType = typeof b

  // TODO SUPPORT SYMBOLS
  if (type !== otherType || type !== 'object' || a.constructor !== b.constructor) {
    return false
  }

  if (Array.isArray(a)) {
    if (a.length === b.length) return a.every((el, i) => deepEquals(el, b[i]))
    return false
  }

  const names = Object.getOwnPropertyNames(a)
  if (names.length !== Object.getOwnPropertyNames(b).length) return false
  return names.every((n) => b.hasOwnProperty(n) &amp;&amp; deepEquals(a[n], b[n]))
}

const messageField = /{([\s\S]+?)}/g
function processMessage (message, values) {
  return message.replace(messageField, (match, field) => {
    if (field in values) return values[field]
    return match
  })
}

function requireTestFunction (fn, message = 'Test function required') {
  if (typeof fn !== 'function') throw new Error(message)
}

/**
 * Assertions will throw this error when a test fails
 * @static
 */
class AssertionError extends Error {
  /**
   * @param {string} message - Error message
   * @param {*} [actual] - Actual value
   * @param {*} [expected] - Actual value
   */
  constructor (message, actual, expected) {
    super(message)
    this.name = 'Assertion Error'
    this.actual = actual
    this.expected = expected
  }
}

/**
 * This callback is displayed as part of the Requester class.
 * @callback assertionCallback
 * @param {module:xassert.Assertion} it
 */

/**
 * It contains all the assertion methods.
 * @static
 */
class Assertion {
  /**
   * Do no use it directly. Use the [module function]{@link module:xassert}
   * @param {*} ref - actual value, promise or function
   * @param {string} [name] - name of the field that could be used in the error messages
   * @param {ValueAssertion} [parent] - parent assertion
   */
  constructor (ref, name, parent) {
    this.ref = ref
    this.name = name
    this.parent = parent
  }

  /**
   * @example
   * console.log(assert('orange').isAString().getRef()) // prints 'orange'
   * @returns {*} current value
   */
  getRef () {
    return this.ref
  }

  /**
   * @example
   * console.log(assert('orange').isAString().getName()) // prints 'actual value'
   * console.log(assert('orange', 'fruit').isAString().getName()) // prints 'fruit'
   * @returns {string} current name
   */
  getName () {
    if (this.name) return this.name
    if (isAPromise(this.ref)) return 'promise'
    if (typeof this.ref === 'function') return 'function'
    return 'actual value'
  }

  /**
   * @returns {string} full name including parent names
   */
  getFullName () {
    return this.parent ? this.parent.getFullName() + ' ' + this.getName() : this.getName()
  }

  /**
   * It could be use for meaningful chains
   * @example
   * assert('a').isAString().andIt.hasLengthOf(1)
   * @member {this}
   */
  get andIt () {
    return this
  }

  /**
   * @param {string} name - name of the field
   * @returns {Assertion} new ValueAssertion with the same value and a new name
   */
  named (name) {
    return new Assertion(this.ref, name)
  }

  /**
   * @private
   */

  /**
   * It fires an AssertionError
   * @private
   * @param {string} message - error message
   * @param {*} [expected] - expected value
   * @returns {void}
   */
  fire (message, expected) {
    throw new AssertionError(
      processMessage(message, { name: this.getFullName() }),
      this.ref, expected)
  }

  /**
   * Test if the actual value is strictly equal to expected value
   *
   * @example
   * assert(value).isEqualTo('Banana')
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not strictly equal to expected value
   * @return {this} chainable method
   */
  isEqualTo (expected, message = '{name} is different than expected value') {
    if (expected !== this.ref) this.fire(message, expected)
    return this
  }

  /**
   * Test if the actual value is strictly equal to any of expected values
   *
   * @example
   * assert(value).isEqualToAnyOf(['Banana', 'Apple'])
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not strictly equal to any of expected values
   * @return {this} chainable method
   */
  isEqualToAnyOf (expected, message = '{name} is different than any expected value') {
    if (expected.every(arg => arg !== this.ref)) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is not strictly equal to expected value
   *
   * @example
   * assert(value).isNotEqualTo('Banana')
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is strictly equal to expected value
   * @return {this} chainable method
   */
  isNotEqualTo (expected, message = '{name} is equal to expected value') {
    if (expected === this.ref) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is not strictly equal to any of expected values
   *
   * @example
   * assert(value).isNotEqualToAnyOf(['Banana', 'Apple'])
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is strictly equal to any of expected values
   * @return {this} chainable method
   */
  isNotEqualToAnyOf (expected, message = '{name} is equal to some expected value') {
    if (expected.some(arg => arg === this.ref)) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is deeply equal to expected value
   *
   * @example
   * assert({ c: 3 }).isDeeplyEqualTo({ c: 3 }) // Success
   * assert({ c: 3 }).isDeeplyEqualTo('3') // Fail
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not deeply equal to expected value
   * @return {this} chainable method
   */
  isDeeplyEqualTo (expected, message = '{name} is not deeply equal to expected value') {
    if (!deepEquals(this.ref, expected)) this.fire(message, expected)
    return this
  }

  /**
   * Alias of {@link module:xassert.Assertion#isDeeplyEqualTo}
   * @example
   * assert({ c: 3 }).is({ c: 3 }) // Success
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not deeply equal to expected value
   * @return {this} chainable method
   */
  is (expected, message = '{name} is not expected value') {
    return this.isDeeplyEqualTo(expected, message)
  }
  /**
   * Test if the actual value is not deeply equal to expected value
   *
   * @example
   * assert({ c: 3 }).isNotDeeplyEqualTo({ c: 3 }) // Fail
   * assert({ c: 3 }).isNotDeeplyEqualTo('3') // Success
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is deeply equal to expected values
   * @return {this} chainable method
   */
  isNotDeeplyEqualTo (expected, message = 'actual is deeply equal to expected') {
    if (deepEquals(this.ref, expected)) this.fire(message, expected)
    return this
  }

  /**
   * Test if the actual value is deeply equal to any of expected values
   *
   * @example
   * assert({ c: 3 }).isDeeplyEqualToAnyOf([{ a: 3 } ,{ c: 3 }]) // Success
   * assert({ c: 3 }).isDeeplyEqualToAnyOf([{ a: 3 } ,{ c: 4 }])') // Fail
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not deeply equal to any of expected values
   * @return {this} chainable method
   */
  isDeeplyEqualToAnyOf (expected, message = '{name} is different than any of the expected values') {
    if (expected.every(arg => !deepEquals(this.ref, arg))) {
      this.fire(message)
    }
    return this
  }

  /**
   * Test if the actual value is not deeply equal to any of expected values
   *
   * @example
   * assert({ c: 3 }).isNotDeeplyEqualToAnyOf([{ a: 3 } ,{ c: 3 }]) // Fail
   * assert({ c: 3 }).isNotDeeplyEqualToAnyOf([{ a: 3 } ,{ c: 4 }])') // Success
   * @param {*} expected - expected value
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is deeply equal to any of expected values
   * @return {this} chainable method
   */
  isNotDeeplyEqualToAnyOf (expected, message = '{name} is equal one of non expected values') {
    if (expected.some(arg => deepEquals(this.ref, arg))) {
      this.fire(message)
    }
    return this
  }

  // ######### IS &amp; IS NOT ############

  /**
   * Test if the actual value is null
   *
   * @example
   * assert(null).isNull() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not null
   * @return {this} chainable method
   */
  isNull (message = '{name} is not null') {
    if (this.ref !== null) this.fire(message, null)
    return this
  }

  /**
   * Test if the actual value is not null
   *
   * @example
   * assert('a').isNotNull() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not null
   * @return {this} chainable method
   */
  isNotNull (message = '{name} is null') {
    if (this.ref === null) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is undefined
   *
   * @example
   * assert(undefined).isUndefined() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not null
   * @return {this} chainable method
   */
  isUndefined (message = '{name} is not undefined') {
    if (typeof this.ref !== 'undefined') this.fire(message, undefined)
    return this
  }

  /**
   * Test if the actual value is not undefined
   *
   * @example
   * assert(undefined).isNotUndefined() // Fail
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is undefined
   * @return {this} chainable method
   */
  isNotUndefined (message = '{name} is undefined') {
    if (typeof this.ref === 'undefined') this.fire(message)
    return this
  }

  /**
   * Test if the actual value is NaN
   *
   * @example
   * assert('j').isNaN() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not NaN
   * @return {this} chainable method
   */
  isNaN (message = '{name} is not NaN') {
    if (!isNaN(this.ref)) this.fire(message, NaN)
    return this
  }

  /**
   * Test if the actual value is not NaN
   *
   * @example
   * assert('j').isNotNaN() // Fail
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is  NaN
   * @return {this} chainable method
   */
  isNotNaN (message = '{name} is NaN') {
    if (isNaN(this.ref)) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is a promise
   *
   * @example
   * assert(Promise.resolve(3)).isAPromise() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not a promise
   * @return {this} chainable method
   */
  isAPromise (message = '{name} is not a promise') {
    if (!isAPromise(this.ref)) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is not promise
   *
   * @example
   * assert(Promise.resolve(3)).isNotAPromise() // Fail
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is a promise
   * @return {this} chainable method
   */
  isNotAPromise (message = '{name} is a promise') {
    if (isAPromise(this.ref)) this.fire(message)
    return this
  }

  /**
   * Test if the actual value is a number
   *
   * @example
   * assert(4.3).isANumber() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not a number
   * @return {this} chainable method
   */
  isANumber (message = '{name} is not a number') {
    if (typeof this.ref !== 'number') this.fire(message)
    return this
  }

  /**
   * Test if the actual value is not a number
   *
   * @example
   * assert(4.3).isNotANumber() // Fail
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is a number
   * @return {this} chainable method
   */
  isNotANumber (message = '{name} is a number') {
    if (typeof this.ref === 'number') this.fire(message)
    return this
  }

  /**
   * Test if the actual value is a string
   *
   * @example
   * assert('banana').isAString() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not a string
   * @return {this} chainable method
   */
  isAString (message = '{name} is not a string') {
    if (typeof this.ref !== 'string') this.fire(message)
    return this
  }

  /**
   * Test if the actual value is not a string
   *
   * @example
   * assert('banana').isNotAString() // Fail
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is a string
   * @return {this} chainable method
   */
  isNotAString (message = '{name} is a string') {
    if (typeof this.ref === 'string') this.fire(message)
    return this
  }

  /**
   * Test if the actual value is an array
   *
   * @example
   * assert([2, 3]).isAnArray() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is not an array
   * @return {this} chainable method
   */
  isAnArray (message = '{name} is not an array') {
    if (!Array.isArray(this.ref)) this.fire(message, this.ref)
    return this
  }

  /**
   * Test if the actual value is not an array
   *
   * @example
   * assert(33).isNotAnArray() // Success
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value is an array
   * @return {this} chainable method
   */
  isNotAnArray (message = '{name} is an array') {
    if (Array.isArray(this.ref)) this.fire(message, this.ref)
    return this
  }

  /**
   * Test if every value of the array pass the test
   * @example
   * assert([3, 6]).every(it => it.isAbove(2)) // Success
   * @param {module:xassert~assertionCallback} test - test for each element
   * @throws {module:xassert.AssertionError} when any value fails the test
   * @return {this} chainable method
   */
  every (test) {
    requireTestFunction(test)
    this.ref.forEach((it, i) => test(new Assertion(it, 'at index ' + i, this)))
    return this
  }

  /**
   * Test if some value of the array pass the test
   * @example
   * assert([3, 6]).some(it => it.isAbove(5)) // Success
   * @param {module:xassert~assertionCallback} test - test for each element
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when no value passes the test
   * @return {this} chainable method
   */
  some (test, message = '{name} does not contain any item that passes any test') {
    requireTestFunction(test)
    const result = this.ref.some(it => {
      try { test(new Assertion(it)) } catch (error) {
        if (error instanceof AssertionError) return false
        throw error
      }
      return true
    })
    if (!result) this.fire(message)
    return this
  }

  /**
   * Test if the actual value has the given property and run some test on it
   * @example
   * assert({ a: 3 }).hasProperty('a', it => it.isAbove(2)) // Success
   * @param {string} name - name of the property
   * @param {module:xassert~assertionCallback} test - test for the property
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value does not have
   * the given property or the tests fails
   * @return {this} chainable method
   */
  hasProperty (name, test, message = '{name} does not contain the property {property}') {
    if (!(this.ref &amp;&amp; name in this.ref)) this.fire(processMessage(message, { property: name }))
    if (typeof test === 'function') test(new Assertion(this.ref[name], 'property ' + name, this))
    return this
  }

  /**
   * Test if the actual value does not have the given property
   * @example
   * assert({ a: 3 }).doesNotHaveProperty('b') // Success
   * @param {string} name - name of the property
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value has the given property
   * @return {this} chainable method
   */
  doesNotHaveProperty (name, message = '{name} contains the property {property}') {
    if (this.ref &amp;&amp; name in this.ref) this.fire(processMessage(message, { property: name }))
    return this
  }

  /**
   * Test if the actual value has the own given property and run some test on it
   * @example
   * assert({ a: 3 }).hasOwnProperty('a', it => it.isAbove(2)) // Success
   * @param {string} name - name of the property
   * @param {module:xassert~assertionCallback} test - test for the property
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value does not have
   * the own given property or the tests fails
   * @return {this} chainable method
   */
  hasOwnProperty (name, test, message = '{name} does not contain the own property {property}') {
    if (!(this.ref instanceof Object &amp;&amp; this.ref.hasOwnProperty(name))) {
      this.fire(processMessage(message, { property: name }))
    }
    if (typeof test === 'function') test(new Assertion(this.ref[name], 'own property ' + name, this))
    return this
  }

  /**
   * Test if the actual value does not have the own given property
   * @example
   * assert({ a: 3 }).doesNotHaveOwnProperty('b') // Success
   * @param {string} name - name of the property
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the actual value has the own given property
   * @return {this} chainable method
   */
  doesNotHaveOwnProperty (name, message = '{name} contains the own property {property}') {
    if (this.ref instanceof Object &amp;&amp; this.ref.hasOwnProperty(name)) {
      this.fire(processMessage(message, { property: name }))
    }
    return this
  }

  /**
   * Test if the property length exists and optionally pass some test against it
   * @example
   * assert('').hasLength() // Success
   * assert(1).hasLength() // Fails
   * assert([2]).hasLength() // Success
   * assert([2, 5]).hasLength(it => it.isAbove(1)) // Success
   * @param {module:xassert~assertionCallback} [test] - test for the property
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the property does not exists or the test fails
   * @return {this} chainable method
   */
  hasLength (test, message = '{name} does not have length property') {
    const ref = this.ref
    // Empty strings are falsy
    if (ref === null || ref === undefined || typeof ref.length !== 'number') this.fire(message)
    // 'length' in 'a string' throws an error
    if (typeof test === 'function') test(new Assertion(ref.length, 'length property', this))
    return this
  }
  /**
   * Test if the property length exists and it is equal to the giving number
   * @example
   * assert('').hasLengthOf(0) // Success
   * assert(1).hasLengthOf(1) // Fails
   * assert([2, 3]).hasLengthOf(2) // Success
   * @param {number} expected - expected length
   * @param {string} [message] - error message
   * @throws {module:xassert.AssertionError} when the property does not exists or the test fails
   * @return {this} chainable method
   */
  hasLengthOf (expected, message) {
    this.hasLength(it => it.isEqualTo(expected, message))
    return this
  }

  isAbove (number, message = '{name} is not above expected value') {
    if (this.ref &lt;= number) this.fire(message, number)
    return this
  }

  isAtLeast (number, message = '{name} is not at least as expected value') {
    if (this.ref &lt; number) this.fire(message, number)
    return this
  }

  isBelow (number, message = '{name} is not below expected value') {
    if (this.ref >= number) this.fire(message, number)
    return this
  }

  isAtMost (number, message = '{name} is not at most as expected') {
    if (this.ref > number) this.fire(message, number)
    return this
  }

  satisfies (cb) {
    if (typeof cb !== 'function') throw new Error('satisfies requires a callback function')
    const result = cb(this.ref)
    if (!result) this.fire('It does not satisfy')
    return this
  }

  isInstanceOf (expected, message = '{name} is not instance of class ' + expected.name) {
    if (!(this.ref instanceof expected)) this.fire(message, expected)
    return this
  }

  isFrozen (message = '{name} is not frozen') {
    if (!Object.isFrozen(this.ref)) this.fire(message)
    return this
  }

  isNotFrozen (message = '{name} is frozen') {
    if (Object.isFrozen(this.ref)) this.fire(message)
    return this
  }

  isFulfilled (test, message = '{name} has been rejected') {
    return this.ref.then(
      value => typeof test === 'function' ? test(new Assertion(value)) : value,
      ex => this.fire(message)
    )
  }

  isRejected (cb, message = '{name} has been fulfilled') {
    return this.ref.then(
      value => this.fire(message),
      ex => typeof cb === 'function' ? cb(new Assertion(ex)) : ex
    )
  }

  throws (test, message = '{name} did not throw') {
    try {
      this.ref()
    } catch (error) {
      if (test) {
        if (typeof test !== 'function') throw new Error('first parameters should be a function')
        test(new Assertion(error))
      }
      return this
    }
    this.fire(message)
  }

  throwsA (ref) {
    return this.throws(it => it.isInstanceOf(ref))
  }

  throwsAn (ref) {
    return this.throwsA(ref)
  }
}

/**
 * Creates and returns a value assertion
 * @alias module:xassert
 * @param {*} ref - actual value, promise or function
 * @param {string} [name] - alias for the actual value
 * @returns {module:xassert.Assertion} new assertion instance
 * @example
 * const assert = require('xassert')
 * assert(4).isANumber()
 */
function assert (ref, name) {
  return new Assertion(ref, name)
}

assert.Assertion = Assertion
assert.AssertionError = AssertionError

module.exports = assert
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Mar 25 2018 18:34:52 GMT+0200 (CEST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
